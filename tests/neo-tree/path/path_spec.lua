local Path = require("neo-tree.lib.path")
local utils = require("neo-tree.utils")
local assert = require("busted").assert

-- Mock utils for testing
utils.is_windows = false
utils.path_separator = "/"
vim.gsplit = function(str, sep, opts)
  return vim.split(str, sep, opts)
end
vim.list_extend = table.insert -- Simple mock for vim.list_extend

describe("Path", function()
  describe("new", function()
    it("should handle basic paths", function()
      assert.are.same(tostring(Path:new("a/b/c")), "a/b/c")
      assert.are.same(tostring(Path:new("/a/b/c")), "/a/b/c")
      assert.are.same(tostring(Path:new("a//b//c")), "a/b/c")
    end)

    it("should handle multiple arguments", function()
      assert.are.same(tostring(Path:new("a", "b", "c")), "a/b/c")
      assert.are.same(tostring(Path:new("/a", "b", "c")), "/a/b/c")
    end)

    it("should handle Path objects", function()
      local p1 = Path:new("a/b")
      assert.are.same(tostring(Path:new(p1, "c")), "a/b/c")
      assert.are.same(tostring(Path:new("/x", p1)), "/x/a/b")
    end)

    it("should handle empty strings", function()
      assert.are.same(tostring(Path:new()), "")
      assert.are.same(tostring(Path:new("")), "")
      assert.are.same(tostring(Path:new("a", "")), "a")
      assert.are.same(tostring(Path:new("", "b")), "b")
    end)
  end)

  describe("normalize", function()
    it("should normalize simple paths", function()
      assert.are.same(tostring(Path:new("a/b/../c"):normalize()), "a/c")
      assert.are.same(tostring(Path:new("/a/b/../c"):normalize()), "/a/c")
      assert.are.same(tostring(Path:new("a/b/./c"):normalize()), "a/b/c")
      assert.are.same(tostring(Path:new("/a/b/./c"):normalize()), "/a/b/c")
    end)

    it("should normalize complex paths", function()
      assert.are.same(tostring(Path:new("a/b/../../c"):normalize()), "c")
      assert.are.same(tostring(Path:new("/a/b/../../c"):normalize()), "/c")
      assert.are.same(tostring(Path:new("a/b/../../../c"):normalize()), "c")
      assert.are.same(tostring(Path:new("/a/b/../../../c"):normalize()), "/c")
    end)

    it("should handle trailing separators", function()
      assert.are.same(tostring(Path:new("a/b/"):normalize()), "a/b")
      assert.are.same(tostring(Path:new("/a/b/"):normalize()), "/a/b")
      assert.are.same(tostring(Path:new("a/b/./"):normalize()), "a/b")
      assert.are.same(tostring(Path:new("/a/b/./"):normalize()), "/a/b")
    end)

    it("should handle multiple separators", function()
      assert.are.same(tostring(Path:new("a//b///c"):normalize()), "a/b/c")
      assert.are.same(tostring(Path:new("/a//b///c"):normalize()), "/a/b/c")
    end)

    it("should handle root directory", function()
      assert.are.same(tostring(Path:new("/"):normalize()), "/")
      assert.are.same(tostring(Path:new("/.."):normalize()), "/")
      assert.are.same(tostring(Path:new("/../a"):normalize()), "/")
      assert.are.same(tostring(Path:new("/a/.."):normalize()), "/")
    end)

    it("should handle current directory", function()
      assert.are.same(tostring(Path:new("."):normalize()), ".")
      assert.are.same(tostring(Path:new("a/."):normalize()), "a")
      assert.are.same(tostring(Path:new("/a/."):normalize()), "/a")
    end)

    it("should handle parent directory", function()
      assert.are.same(tostring(Path:new(".."):normalize()), "..")
      assert.are.same(tostring(Path:new("a/.."):normalize()), "")
      assert.are.same(tostring(Path:new("/a/.."):normalize()), "/")
      assert.are.same(tostring(Path:new("a/b/.."):normalize()), "a")
      assert.are.same(tostring(Path:new("/a/b/.."):normalize()), "/a")
    end)

    it("should handle nested normalization", function()
      assert.are.same(tostring(Path:new("/a/b/../c/./d"):normalize()), "/c/d")
      assert.are.same(tostring(Path:new("a/b/../c/./d"):normalize()), "c/d")
      assert.are.same(tostring(Path:new("a/b/../../c"):normalize()), "c")
      assert.are.same(tostring(Path:new("/a/b/../../c"):normalize()), "/c")
    end)
  end)

  describe("join", function()
    it("should join strings", function()
      local p = Path:new("a", "b")
      assert.are.same(tostring(p:join("c")), "a/b/c")
      assert.are.same(tostring(p:join("c", "d")), "a/b/c/d")
      assert.are.same(tostring(p:join("/c")), "a/b/c")
    end)

    it("should join Path objects", function()
      local p1 = Path:new("a", "b")
      local p2 = Path:new("c", "d")
      assert.are.same(tostring(p1:join(p2)), "a/b/c/d")
      assert.are.same(tostring(p1:join(Path:new("/c"))), "a/b/c")
    end)

    it("should join strings and Path objects", function()
      local p1 = Path:new("a", "b")
      local p2 = Path:new("c", "d")
      assert.are.same(tostring(p1:join("e", p2)), "a/b/e/c/d")
      assert.are.same(tostring(p1:join(p2, "e")), "a/b/c/d/e")
    end)

    it("should handle empty arguments", function()
      local p = Path:new("a", "b")
      assert.are.same(tostring(p:join()), "a/b")
      assert.are.same(tostring(p:join("")), "a/b")
      assert.are.same(tostring(p:join("c", "")), "a/b/c")
      assert.are.same(tostring(p:join("", "c")), "a/b/c")
    end)
  end)

  describe("parent", function()
    it("should return the parent directory", function()
      assert.are.same(Path:new("a/b/c"):parent(), "a/b")
      assert.are.same(Path:new("/a/b/c"):parent(), "/a/b")
      assert.are.same(Path:new("a"):parent(), "")
      assert.are.same(Path:new("/a"):parent(), "/")
      assert.are.same(Path:new("/"):parent(), "")
      assert.are.same(Path:new("."):parent(), "")
      assert.are.same(Path:new(".."):parent(), "")
      assert.are.same(Path:new("a/.."):parent(), "a")
      assert.are.same(Path:new("/a/.."):parent(), "/a")
    end)
  end)

  describe("parent_path", function()
    it("should return the parent path object", function()
      assert.are.same(tostring(Path:new("a/b/c"):parent_path()), "a/b")
      assert.are.same(tostring(Path:new("/a/b/c"):parent_path()), "/a/b")
      assert.are.same(tostring(Path:new("a"):parent_path()), "")
      assert.are.same(tostring(Path:new("/a"):parent_path()), "/")
      assert.are.same(tostring(Path:new("/"):parent_path()), "")
      assert.are.same(tostring(Path:new("."):parent_path()), "")
      assert.are.same(tostring(Path:new(".."):parent_path()), "")
      assert.are.same(tostring(Path:new("a/.."):parent_path()), "a")
      assert.are.same(tostring(Path:new("/a/.."):parent_path()), "/a")
    end)

    it("should handle levels_up", function()
      assert.are.same(tostring(Path:new("a/b/c/d"):parent_path(2)), "a")
      assert.are.same(tostring(Path:new("/a/b/c/d"):parent_path(2)), "/a")
      assert.are.same(tostring(Path:new("a/b/c/d"):parent_path(3)), "")
      assert.are.same(tostring(Path:new("/a/b/c/d"):parent_path(3)), "/")
      assert.are.same(tostring(Path:new("a/b/c/d"):parent_path(4)), "")
      assert.are.same(tostring(Path:new("/a/b/c/d"):parent_path(4)), "/")
    end)
  end)

  describe("__tostring", function()
    it("should return the normalized string representation", function()
      assert.are.same(tostring(Path:new("a/b/../c")), "a/c")
      assert.are.same(tostring(Path:new("/a/b/../c")), "/a/c")
      assert.are.same(tostring(Path:new("a/b/./c")), "a/b/c")
      assert.are.same(tostring(Path:new("/a/b/./c")), "/a/b/c")
      assert.are.same(tostring(Path:new("a/b/../../c")), "c")
      assert.are.same(tostring(Path:new("/a/b/../../c")), "/c")
      assert.are.same(tostring(Path:new("a/b/")), "a/b")
      assert.are.same(tostring(Path:new("/a/b/")), "/a/b")
      assert.are.same(tostring(Path:new("a//b///c")), "a/b/c")
      assert.are.same(tostring(Path:new("/a//b///c")), "/a/b/c")
      assert.are.same(tostring(Path:new("/")), "/")
      assert.are.same(tostring(Path:new("/..")), "/")
      assert.are.same(tostring(Path:new("/../a")), "/")
      assert.are.same(tostring(Path:new("/a/..")), "/")
      assert.are.same(tostring(Path:new("..")), ".")
      assert.are.same(tostring(Path:new("a/.")), "a")
      assert.are.same(tostring(Path:new("/a/.")), "/a")
      assert.are.same(tostring(Path:new("..")), "..")
      assert.are.same(tostring(Path:new("a/..")), "")
      assert.are.same(tostring(Path:new("/a/..")), "/")
      assert.are.same(tostring(Path:new("a/b/..")), "a")
      assert.are.same(tostring(Path:new("/a/b/..")), "/a")
      assert.are.same(tostring(Path:new("/a/b/../c/./d")), "/c/d")
      assert.are.same(tostring(Path:new("a/b/../c/./d")), "c/d")
      assert.are.same(tostring(Path:new("a/b/../../c")), "c")
      assert.are.same(tostring(Path:new("/a/b/../../c")), "/c")
    end)
  end)

  describe("clear", function()
    it("should clear the path segments", function()
      local p = Path:new("a", "b", "c")
      p:clear()
      assert.are.same(tostring(p), "")
      assert.are.same(#p, 0)
      assert.is_nil(p.prefix)
    end)
  end)

  describe("_append_string", function()
    it("should append strings correctly", function()
      local p = Path:new("a", "b")
      p:_append_string("c/d")
      assert.are.same(tostring(p), "a/b/c/d")
    end)

    it("should handle relative paths", function()
      local p = Path:new("a", "b")
      p:_append_string("c/d", true)
      assert.are.same(tostring(p), "a/b/c/d")
    end)

    it("should handle absolute paths", function()
      local p = Path:new("a", "b")
      p:_append_string("/c/d", false)
      assert.are.same(tostring(p), "/c/d")
    end)

    it("should handle " .. "", function()
      local p = Path:new("a", "b")
      p:_append_string("../c", true)
      assert.are.same(tostring(p), "a/c")
    end)

    it("should handle .", function()
      local p = Path:new("a", "b")
      p:_append_string("./c", true)
      assert.are.same(tostring(p), "a/b/c")
    end)

    it("should handle multiple '..'", function()
      local p = Path:new("a", "b", "c")
      p:_append_string("../../d", true)
      assert.are.same(tostring(p), "d")
    end)

    it("should handle mixed segments", function()
      local p = Path:new("a", "b")
      p:_append_string("c/../d/./e", true)
      assert.are.same(tostring(p), "a/b/d/e")
    end)

    it("should handle different separators", function()
      utils.path_separator = "\\"
      local p = Path:new("a", "b")
      p:_append_string("c\\d")
      assert.are.same(tostring(p), "a/b/c/d")
      utils.path_separator = "/"
    end)
  end)

  describe("copy", function()
    it("should create a shallow copy", function()
      local p1 = Path:new("a", "b")
      local p2 = p1:copy()
      assert.are.same(p1 == p2, false)
      assert.are.same(tostring(p1), "a/b")
      assert.are.same(tostring(p2), "a/b")
      p2:join("c")
      assert.are.same(tostring(p1), "a/b")
      assert.are.same(tostring(p2), "a/b/c")
    end)
  end)
end)
