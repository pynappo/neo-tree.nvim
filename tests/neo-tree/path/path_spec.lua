local Path = require("neo-tree.lib.path")
local utils = require("neo-tree.utils")

-- Mock utils for testing
utils.is_windows = false
utils.path_separator = "/"
describe("Path", function()
  describe("new", function()
    it("should handle basic paths", function()
      assert.are.same("a/b/c", tostring(Path:new("a/b/c")))
      assert.are.same("/a/b/c", tostring(Path:new("/a/b/c")))
      assert.are.same("a/b/c", tostring(Path:new("a//b//c")))
    end)

    it("should handle multiple arguments", function()
      assert.are.same("a/b/c", tostring(Path:new("a", "b", "c")))
      assert.are.same("/a/b/c", tostring(Path:new("/a", "b", "c")))
    end)

    it("should handle Path objects", function()
      local p1 = Path:new("a/b")
      assert.are.same("a/b/c", tostring(Path:new(p1, "c")))
      assert.are.same("/x/a/b", tostring(Path:new("/x", p1)))
    end)

    it("should handle empty strings", function()
      assert.are.same("", tostring(Path:new()))
      assert.are.same("", tostring(Path:new("")))
      assert.are.same("a", tostring(Path:new("a", "")))
      assert.are.same("b", tostring(Path:new("", "b")))
    end)
  end)

  describe("normalize", function()
    it("should normalize simple paths", function()
      assert.are.same("a/c", tostring(Path:new("a/b/../c")))
      assert.are.same("/a/c", tostring(Path:new("/a/b/../c")))
      assert.are.same("a/b/c", tostring(Path:new("a/b/./c")))
      assert.are.same("/a/b/c", tostring(Path:new("/a/b/./c")))
    end)

    it("should normalize complex paths", function()
      assert.are.same("c", tostring(Path:new("a/b/../../c")))
      assert.are.same("/c", tostring(Path:new("/a/b/../../c")))
      assert.are.same("../c", tostring(Path:new("a/b/../../../c")))
      assert.are.same("/c", tostring(Path:new("/a/b/../../../c")))
    end)

    it("should handle trailing separators", function()
      assert.are.same("a/b", tostring(Path:new("a/b/")))
      assert.are.same("/a/b", tostring(Path:new("/a/b/")))
      assert.are.same("a/b", tostring(Path:new("a/b/./")))
      assert.are.same("/a/b", tostring(Path:new("/a/b/./")))
    end)

    it("should handle multiple separators", function()
      assert.are.same("a/b/c", tostring(Path:new("a//b///c")))
      assert.are.same("/a/b/c", tostring(Path:new("/a//b///c")))
    end)

    it("should handle root directory", function()
      assert.are.same("/", tostring(Path:new("/")))
      assert.are.same("/", tostring(Path:new("/..")))
      assert.are.same("/", tostring(Path:new("/a/..")))
    end)

    it("should handle current directory", function()
      assert.are.same(".", tostring(Path:new(".")))
      assert.are.same("a", tostring(Path:new("a/.")))
      assert.are.same("/a", tostring(Path:new("/a/.")))
    end)

    it("should handle parent directory", function()
      assert.are.same("..", tostring(Path:new("..")))
      assert.are.same("", tostring(Path:new("a/..")))
      assert.are.same("/", tostring(Path:new("/a/..")))
      assert.are.same("a", tostring(Path:new("a/b/..")))
      assert.are.same("/a", tostring(Path:new("/a/b/..")))
    end)

    it("should handle nested normalization", function()
      assert.are.same("/a/c/d", tostring(Path:new("/a/b/../c/./d")))
      assert.are.same("a/c/d", tostring(Path:new("a/b/../c/./d")))
      assert.are.same("c", tostring(Path:new("a/b/../../c")))
      assert.are.same("/c", tostring(Path:new("/a/b/../../c")))
    end)
  end)

  describe("join", function()
    it("should join strings", function()
      local p = Path:new("a", "b")
      assert.are.same("a/b/c", tostring(p:join("c")))
      assert.are.same("a/b/c/d", tostring(p:join("c", "d")))
      assert.are.same("a/b/c", tostring(p:join("/c")))
    end)

    it("should join Path objects", function()
      local p1 = Path:new("a", "b")
      local p2 = Path:new("c", "d")
      assert.are.same("a/b/c/d", tostring(p1:join(p2)))
      assert.are.same("a/b/c", tostring(p1:join(Path:new("/c"))))
    end)

    it("should join strings and Path objects", function()
      local p1 = Path:new("a", "b")
      local p2 = Path:new("c", "d")
      assert.are.same("a/b/e/c/d", tostring(p1:join("e", p2)))
      assert.are.same("a/b/c/d/e", tostring(p1:join(p2, "e")))
    end)

    it("should handle empty arguments", function()
      local p = Path:new("a", "b")
      assert.are.same("a/b", tostring(p:join()))
      assert.are.same("a/b", tostring(p:join("")))
      assert.are.same("a/b/c", tostring(p:join("c", "")))
      assert.are.same("a/b/c", tostring(p:join("", "c")))
    end)
  end)

  describe("parent", function()
    it("should return the parent directory", function()
      assert.are.same("a/b", Path:new("a/b/c"):parent())
      assert.are.same("/a/b", Path:new("/a/b/c"):parent())
      assert.are.same("", Path:new("a"):parent())
      assert.are.same("/", Path:new("/a"):parent())
      assert.are.same("", Path:new("/"):parent())
      assert.are.same("", Path:new("."):parent())
      assert.are.same("", Path:new(".."):parent())
      assert.are.same("a", Path:new("a/.."):parent())
      assert.are.same("/a", Path:new("/a/.."):parent())
    end)
  end)

  describe("parent_path", function()
    it("should return the parent path object", function()
      assert.are.same("a/b", tostring(Path:new("a/b/c"):parent_path()))
      assert.are.same("/a/b", tostring(Path:new("/a/b/c"):parent_path()))
      assert.are.same("", tostring(Path:new("a"):parent_path()))
      assert.are.same("/", tostring(Path:new("/a"):parent_path()))
      assert.are.same("", tostring(Path:new("/"):parent_path()))
      assert.are.same("", tostring(Path:new("."):parent_path()))
      assert.are.same("", tostring(Path:new(".."):parent_path()))
      assert.are.same("a", tostring(Path:new("a/.."):parent_path()))
      assert.are.same("/a", tostring(Path:new("/a/.."):parent_path()))
    end)

    it("should handle levels_up", function()
      assert.are.same("a", tostring(Path:new("a/b/c/d"):parent_path(2)))
      assert.are.same("/a", tostring(Path:new("/a/b/c/d"):parent_path(2)))
      assert.are.same("", tostring(Path:new("a/b/c/d"):parent_path(3)))
      assert.are.same("/", tostring(Path:new("/a/b/c/d"):parent_path(3)))
      assert.are.same("", tostring(Path:new("a/b/c/d"):parent_path(4)))
      assert.are.same("/", tostring(Path:new("/a/b/c/d"):parent_path(4)))
    end)
  end)

  describe("__tostring", function()
    it("should return the normalized string representation", function()
      assert.are.same("a/c", tostring(Path:new("a/b/../c")))
      assert.are.same("/a/c", tostring(Path:new("/a/b/../c")))
      assert.are.same("a/b/c", tostring(Path:new("a/b/./c")))
      assert.are.same("/a/b/c", tostring(Path:new("/a/b/./c")))
      assert.are.same("c", tostring(Path:new("a/b/../../c")))
      assert.are.same("/c", tostring(Path:new("/a/b/../../c")))
      assert.are.same("a/b", tostring(Path:new("a/b/")))
      assert.are.same("/a/b", tostring(Path:new("/a/b/")))
      assert.are.same("a/b/c", tostring(Path:new("a//b///c")))
      assert.are.same("/a/b/c", tostring(Path:new("/a//b///c")))
      assert.are.same("/", tostring(Path:new("/")))
      assert.are.same("/", tostring(Path:new("/..")))
      assert.are.same("/", tostring(Path:new("/../a")))
      assert.are.same("/", tostring(Path:new("/a/..")))
      assert.are.same(".", tostring(Path:new("..")))
      assert.are.same("a", tostring(Path:new("a/.")))
      assert.are.same("/a", tostring(Path:new("/a/.")))
      assert.are.same("..", tostring(Path:new("..")))
      assert.are.same("", tostring(Path:new("a/..")))
      assert.are.same("/", tostring(Path:new("/a/..")))
      assert.are.same("a", tostring(Path:new("a/b/..")))
      assert.are.same("/a", tostring(Path:new("/a/b/..")))
      assert.are.same("/c/d", tostring(Path:new("/a/b/../c/./d")))
      assert.are.same("c/d", tostring(Path:new("a/b/../c/./d")))
      assert.are.same("c", tostring(Path:new("a/b/../../c")))
      assert.are.same("/c", tostring(Path:new("/a/b/../../c")))
    end)
  end)

  describe("clear", function()
    it("should clear the path segments", function()
      local p = Path:new("a", "b", "c")
      p:clear()
      assert.are.same("", tostring(p))
      assert.are.same(#p, 0)
      assert.is_nil(p.prefix)
    end)
  end)

  describe("copy", function()
    it("should create a shallow copy", function()
      local p1 = Path:new("a", "b")
      local p2 = p1:copy()
      assert.are.same(p1 == p2, false)
      assert.are.same("a/b", tostring(p1))
      assert.are.same("a/b", tostring(p2))
      p2:join("c")
      assert.are.same("a/b", tostring(p1))
      assert.are.same("a/b/c", tostring(p2))
    end)
  end)
end)
